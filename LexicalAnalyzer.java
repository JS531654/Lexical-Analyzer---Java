import java.io.*;
public class LexicalAnalyzer {
	/**
	 * Token Codes 
	 */
	public static final int EOF = -1; 
	public static final int letter = 0; 
	public static final int digit = 1;
	public static final int UNKNOWN = 99; 
	public static final int intLiteral = 10; 
	public static final int ident = 11;
	public static final int assignOp = 20; 
	public static final int addOp = 21; 
	public static final int subOp = 22; 
	public static final int multOp = 23; 
	public static final int divOp = 24; 
	public static final int leftParen = 25; 
	public static final int rightParen = 26; 
	public static final int forCode = 30; 
	public static final int ifCode = 31;
	public static final int elseCode = 32;
	public static final int whileCode = 33; 
	public static final int doCode = 34; 
	public static final int intCode = 35; 
	public static final int floatCode = 36;
	public static final int switchCode = 37; 
	
	
	/**
	 * Global Variable Declarations
	 */
	File test;
	int charClass; 
	char[] lexeme = new char[100];
	char nextChar; 
	int lexLen;
	int number;
	int alpha; 
	int unknown; 
	int token; 
	int nextToken; 
	/**
	 * A function to lookup operations and parentheses and return the token 
	 * @param ch The character to be looked up 
	 * @return Returns the next token 
	 */
	public int lookup(char ch)
	{
		switch(ch)
		{
		case'(': 
			addChar(); 
			nextToken = leftParen;
			break; 
		case')': 
			addChar(); 
			nextToken = rightParen;
			break;
			
		case'+': 
			addChar(); 
			nextToken = addOp;
			break;
		case'-': 
			addChar(); 
			nextToken = subOp;
			break;
		case'*': 
			addChar(); 
			nextToken = multOp;
			break;
		case'/': 
			addChar(); 
			nextToken = divOp;
			break;
		default: 
			addChar(); 
			nextToken = EOF; 
			
		}
		return nextToken; 
	}
	
	/**
	 * Function to add the value stored in nextChar to lexeme
	 */
	public void addChar()
	{
		if(lexLen <= 98)
		{
			lexeme[lexLen++] = nextChar;
		}
		else
		{
			System.out.println("Error- lexeme is too long"); 
		}
	}
	/**
	 * A function to get the next character of the input and determine its character class 
	 * @throws IOException Throws the file not found exception 
	 */
	public void getChar() throws IOException
	{
		BufferedReader reader = new BufferedReader(new FileReader(test));
		if(reader.readLine() != null)
		{
			if(Character.isLetter(nextChar))
			{
				charClass = letter; 
			}
			else if(Character.isDigit(nextChar))
			{
				charClass = digit; 
			}
			else 
			{
				charClass = UNKNOWN; 
			}
		}
		else
		{
			charClass = EOF; 
		}
	}
	/**
	 * A function to call getChar until it returns a non-whitespace character
	 * @throws IOException Throws the file not found exception 
	 */
	public void getNonSpace() throws IOException
	{
		while(Character.isSpace(nextChar))
		{
			getChar(); 
		}
	}
	/**
	 * A simple lexical analyzer for arithmetic expressions
	 * @return Returns the next token in the string 
	 * @throws IOException Throws the file not found exception 
	 */
	public int lex() throws IOException
	{
		lexLen = 0; 
		getNonSpace(); 
		switch(charClass)
		{
		case letter: 
			addChar(); 
			getChar(); 
			while(charClass == letter || charClass == digit)
			{
				addChar();
				getChar(); 
			}
			nextToken = ident;
			break; 
		case digit: 
			addChar(); 
			getChar(); 
			while(charClass == digit)
			{
				addChar();
				getChar(); 
			}
			nextToken = intLiteral;
			break; 
		case UNKNOWN: 
			lookup(nextChar);
			getChar();
			break;
		case EOF: 
			nextToken = EOF; 
			lexeme[0] = 'E';
			lexeme[1] = 'O';
			lexeme[2] = 'F';
			lexeme[3] = 0;
		}
		System.out.println("Next token is: " + nextToken + ", Next lexeme is " + (lexeme));
		return nextToken; 
	}
	/**
	 * Parses strings in the language generated by rule <expr> - > <term> {(+ | -) <term>}
	 * @throws IOException Throws file not found exception
	 */
	public void expr() throws IOException
	{
		
		System.out.println("Enter <expr>");
		term(); 
		while(nextToken == addOp || nextToken == subOp)
		{
			lex();
			term();
		}
		System.out.println("Exit <expr>");
	}
	/**
	 * Parses strings in the language generated by the rule: <term> - > <factor> {(* | /) <factor>)
	 * @throws IOException Throws file not found exception
	 */
	public void term() throws IOException
	{
		System.out.println("Enter <term>");
		factor();
		while(nextToken == multOp || nextToken == divOp)
		{
			lex(); 
			factor(); 
		}
		System.out.println("Exit <term>");

	}
	/**
	 * Parses strings in the language generated by the rule <factor> â†’ id | int_constant | ( <expr> )
	 * @throws IOException Throws file not found exception
	 */
	public void factor() throws IOException
	{
		System.out.println("Exit <factor>");
		if(nextToken == ident || nextToken == intLiteral)
		{
			lex(); 
		}
		else
		{
			if(nextToken == leftParen)
			{
				lex();
				expr();
			
				if(nextToken == rightParen)
				{
					lex();
				}
				else
				{
					System.out.println("Error"); 
				}
			}
			System.out.println("Error: It was not an ID, integer literal, or left parenthesis");
		}
	}
	/**
	 * Opens the file and tests the methods in the class
	 * @throws IOException Throws file not found exception
	 */
	public void main() throws IOException
	{
		File test = new File("/Users/johnsyracuse/Desktop/ICSI Eclipse Work/ICSI 311 Project 2/src");
		BufferedReader reader = new BufferedReader(new FileReader(test));
		if(reader.readLine() == null)
		{
			System.out.println("Error cannot open file");
		}
		else
		{
			getChar(); 
			do
			{
				lex();
			}
			while(nextToken != EOF);
		}
	}
}

